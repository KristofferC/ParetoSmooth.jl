{
    "sourceFile": "src/InternalHelpers.jl",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1626565928399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1626565951018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n \"\"\"\n Assume that all objects belong to a single chain if chain index is missing. Inform user.\n \"\"\"\n-function _assume_one_chain(matrix::AbstractMatrix)\n+function _assume_one_chain(matrix)\n     @info \"Chain information was not provided; \" *\n           \"all samples are assumed to be drawn from a single chain.\"\n-    return ones(length(matrix::AbstractMatrix))\n+    return ones(length(matrix))\n end\n \n \n \"\"\"\n"
                },
                {
                    "date": 1626566209767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,12 +11,12 @@\n \"\"\"\n Convert a matrix+chain_index representation to a 3d array representation to pass it off to \n the method for arrays.\n \"\"\"\n-function _convert_to_array(log_ratios::AbstractMatrix, chain_index::AbstractVector)\n+function _convert_to_array(matrix::AbstractMatrix, chain_index::AbstractVector)\n     indices = unique(chain_index)\n     biggest_idx = maximum(indices)\n-    dims = size(log_ratios)\n+    dims = size(matrix)\n     if dims[2] ≠ length(chain_index)\n         throw(ArgumentError(\"Some entries do not have a chain index.\"))\n     elseif !issetequal(indices, 1:biggest_idx)\n         throw(\n@@ -31,10 +31,10 @@\n         if !all(==(counts[1]), counts)\n             throw(ArgumentError(\"All chains must be of equal length.\"))\n         end\n     end\n-    new_ratios = similar(log_ratios, dims[1], dims[2] ÷ biggest_idx, biggest_idx)\n+    new_ratios = similar(matrix, dims[1], dims[2] ÷ biggest_idx, biggest_idx)\n     for i in 1:biggest_idx\n-        new_ratios[:, :, i] .= log_ratios[:, chain_index .== i]\n+        new_ratios[:, :, i] .= matrix[:, chain_index .== i]\n     end\n     return new_ratios\n end\n\\ No newline at end of file\n"
                },
                {
                    "date": 1626574229040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,11 @@\n+const CHAIN_INDEX_DOC = \"\"\"\n+`chain_index::Vector`: An optional vector of integers specifying which chain each \n+    step belongs to. For instance, `chain_index[step]` should return `2` if\n+    `log_likelihood[:, step]` belongs to the second chain.\n \"\"\"\n+\n+\"\"\"\n Assume that all objects belong to a single chain if chain index is missing. Inform user.\n \"\"\"\n function _assume_one_chain(matrix)\n     @info \"Chain information was not provided; \" *\n@@ -8,10 +14,9 @@\n end\n \n \n \"\"\"\n-Convert a matrix+chain_index representation to a 3d array representation to pass it off to \n-the method for arrays.\n+Convert a matrix+chain_index representation to a 3d array representation.\n \"\"\"\n function _convert_to_array(matrix::AbstractMatrix, chain_index::AbstractVector)\n     indices = unique(chain_index)\n     biggest_idx = maximum(indices)\n"
                },
                {
                    "date": 1626622573360,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,20 @@\n     step belongs to. For instance, `chain_index[step]` should return `2` if\n     `log_likelihood[:, step]` belongs to the second chain.\n \"\"\"\n \n+const R_EFF_DOC = \"\"\"\n+`r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \n+in ESS calculations. If left empty, calculated automatically using the FFTESS method \n+from InferenceDiagnostics.jl. See `relative_eff` to calculate these values.\n \"\"\"\n+\n+\n+###############\n+## FUNCTIONS ##\n+###############\n+\n+\"\"\"\n Assume that all objects belong to a single chain if chain index is missing. Inform user.\n \"\"\"\n function _assume_one_chain(matrix)\n     @info \"Chain information was not provided; \" *\n"
                },
                {
                    "date": 1626622639345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,16 @@\n in ESS calculations. If left empty, calculated automatically using the FFTESS method \n from InferenceDiagnostics.jl. See `relative_eff` to calculate these values.\n \"\"\"\n \n+const ARGS = \"\"\"\n+`args...`: Positional arguments to be passed to\n+\"\"\"\n+const KWARGS = \"\"\"\n+`kwargs...`: Keyword arguments to be passed to\n+\"\"\"\n \n+\n ###############\n ## FUNCTIONS ##\n ###############\n \n"
                },
                {
                    "date": 1626631378386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,14 @@\n     step belongs to. For instance, `chain_index[step]` should return `2` if\n     `log_likelihood[:, step]` belongs to the second chain.\n \"\"\"\n \n+const LIKELIHOOD_FUNCTION_ARG = \"\"\"\n+`ll_fun::Function`: A function taking a single data point and returning the log-likelihood \n+of that point. This function must take the form `f(θ[1], ..., θ[n], data)`, where `θ` is the\n+parameter vector. See also the `splat` keyword argument.\n+\"\"\"\n+\n const R_EFF_DOC = \"\"\"\n `r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \n in ESS calculations. If left empty, calculated automatically using the FFTESS method \n from InferenceDiagnostics.jl. See `relative_eff` to calculate these values.\n@@ -12,8 +18,9 @@\n \n const ARGS = \"\"\"\n `args...`: Positional arguments to be passed to\n \"\"\"\n+\n const KWARGS = \"\"\"\n `kwargs...`: Keyword arguments to be passed to\n \"\"\"\n \n"
                },
                {
                    "date": 1627342052525,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,107 @@\n+const CHAIN_INDEX_DOC = \"\"\"\n+`chain_index::Vector`: An optional vector of integers specifying which chain each \n+    step belongs to. For instance, `chain_index[step]` should return `2` if\n+    `log_likelihood[:, step]` belongs to the second chain.\n+\"\"\"\n+\n+const LIKELIHOOD_FUNCTION_ARG = \"\"\"\n+`ll_fun::Function`: A function taking a single data point and returning the log-likelihood \n+of that point. This function must take the form `f(θ[1], ..., θ[n], data)`, where `θ` is the\n+parameter vector. See also the `splat` keyword argument.\n+\"\"\"\n+\n+const R_EFF_DOC = \"\"\"\n+`r_eff::AbstractArray{T}`: An (optional) vector of relative effective sample sizes used \n+in ESS calculations. If left empty, calculated automatically using the FFTESS method \n+from InferenceDiagnostics.jl. See `relative_eff` to calculate these values.\n+\"\"\"\n+\n+const ARGS = \"\"\"\n+`args...`: Positional arguments to be passed to\n+\"\"\"\n+\n+const KWARGS = \"\"\"\n+`kwargs...`: Keyword arguments to be passed to\n+\"\"\"\n+\n+\n+###############\n+## FUNCTIONS ##\n+###############\n+\n+\"\"\"\n+Assume that all objects belong to a single chain if chain index is missing. Inform user.\n+\"\"\"\n+function _assume_one_chain(matrix)\n+    @info \"Chain information was not provided; \" *\n+          \"all samples are assumed to be drawn from a single chain.\"\n+    return ones(length(matrix))\n+end\n+\n+\n+\"\"\"\n+Convert a matrix+chain_index representation to a 3d array representation.\n+\"\"\"\n+function _convert_to_array(matrix::AbstractMatrix, chain_index::AbstractVector)\n+    indices = unique(chain_index)\n+    biggest_idx = maximum(indices)\n+    dims = size(matrix)\n+    if dims[2] ≠ length(chain_index)\n+        throw(ArgumentError(\"Some entries do not have a chain index.\"))\n+    elseif !issetequal(indices, 1:biggest_idx)\n+        throw(\n+            ArgumentError(\n+                \"Indices must be numbered from 1 through the total number of chains.\"\n+            ),\n+        )\n+    else\n+        # Check how many elements are in each chain, assign to \"counts\"\n+        counts = count.(eachslice(chain_index .== indices'; dims=2))\n+        # check if all inputs are the same length\n+        if !all(==(counts[1]), counts)\n+            throw(ArgumentError(\"All chains must be of equal length.\"))\n+        end\n+    end\n+    new_ratios = similar(matrix, dims[1], dims[2] ÷ biggest_idx, biggest_idx)\n+    for i in 1:biggest_idx\n+        new_ratios[:, :, i] .= matrix[:, chain_index .== i]\n+    end\n+    return new_ratios\n+end\n+\n+\"\"\"\n+    _generate_cv_table\n+Generate a table containing the results of cross-validation.\n+\"\"\"\n+function _generate_cv_table(\n+    log_likelihood::AbstractArray, \n+    pointwise::AbstractArray, \n+    data_size::Integer\n+)\n+\n+    # create table with the right labels\n+    table = KeyedArray(\n+        similar(log_likelihood, 3, 4);\n+        criterion=[:loo_est, :naive_est, :overfit],\n+        statistic=[:total, :se_total, :mean, :se_mean],\n+    )\n+\n+    # calculate the sample expectation for the total score\n+    to_sum = pointwise([:loo_est, :naive_est, :overfit])\n+    @tullio averages[crit] := to_sum[data, crit] / data_size\n+    averages = reshape(averages, 3)\n+    table(:, :mean) .= averages\n+\n+    # calculate the sample expectation for the average score\n+    table(:, :total) .= table(:, :mean) .* data_size\n+\n+    # calculate the sample expectation for the standard error in the totals\n+    se_mean = std(to_sum; mean=averages', dims=1) / sqrt(data_size)\n+    se_mean = reshape(se_mean, 3)\n+    table(:, :se_mean) .= se_mean\n+\n+    # calculate the sample expectation for the standard error in averages\n+    table(:, :se_total) .= se_mean * data_size\n+\n+    return table\n+end\n\\ No newline at end of file\n"
                }
            ],
            "date": 1626565928399,
            "name": "Commit-0",
            "content": "\"\"\"\nAssume that all objects belong to a single chain if chain index is missing. Inform user.\n\"\"\"\nfunction _assume_one_chain(matrix::AbstractMatrix)\n    @info \"Chain information was not provided; \" *\n          \"all samples are assumed to be drawn from a single chain.\"\n    return ones(length(matrix::AbstractMatrix))\nend\n\n\n\"\"\"\nConvert a matrix+chain_index representation to a 3d array representation to pass it off to \nthe method for arrays.\n\"\"\"\nfunction _convert_to_array(log_ratios::AbstractMatrix, chain_index::AbstractVector)\n    indices = unique(chain_index)\n    biggest_idx = maximum(indices)\n    dims = size(log_ratios)\n    if dims[2] ≠ length(chain_index)\n        throw(ArgumentError(\"Some entries do not have a chain index.\"))\n    elseif !issetequal(indices, 1:biggest_idx)\n        throw(\n            ArgumentError(\n                \"Indices must be numbered from 1 through the total number of chains.\"\n            ),\n        )\n    else\n        # Check how many elements are in each chain, assign to \"counts\"\n        counts = count.(eachslice(chain_index .== indices'; dims=2))\n        # check if all inputs are the same length\n        if !all(==(counts[1]), counts)\n            throw(ArgumentError(\"All chains must be of equal length.\"))\n        end\n    end\n    new_ratios = similar(log_ratios, dims[1], dims[2] ÷ biggest_idx, biggest_idx)\n    for i in 1:biggest_idx\n        new_ratios[:, :, i] .= log_ratios[:, chain_index .== i]\n    end\n    return new_ratios\nend"
        }
    ]
}